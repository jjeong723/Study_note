프로그래밍 대회에서 배우는 알고리즘 문제해결전략
===
> 알고리즘 1번 책 4장

# 2부 알고리즘 분석

알고리즘은 컴퓨터가 어떤 작업을 해결하는 방법을 가리킴

같은 작업이라도 여러가지 해결 방안이 존재하지만, 주어진 문제를 해결하는 방법을 명료하게 써 놓은 것을 알고리즘이라고 한다.

* **정당한 알고리즘**
```
1. 지하철 2호선을 타고 시청역으로 간다.
2. 지하철 1호선으로 갈아타고 청량리역으로 간다.
3. 경춘선을 타고, 춘천역에서 내린다.
```

* **알고리즘 아님**
```
1. 강동구 쪽으로 가는 버스를 탄다.
2. 동서울 버스 터미널 근처에 온 것 같으면 내린다.
3. 춘천 쪽으로 가는 버스를 타고, 한참 가다 내린다.
```

전자는 알고리즘이 맞지만, 후자는 주관적이기 때문에 모호하기때문에 알고리즘이라고 할 수 없다.

 - - -
이렇게 하나의 문제에 대해서 다양한 알고리즘 방법이 존재하기때문에 이에 따른 평가가 필요하다.
알고리즘을 평가하는 두가지 큰 기준은 *시간*, *공간* 이다.
* 시간: 알고리즘이 적은 시간에 동작하는 것
* 공간: 알고리즘이 적은 공간을 사용하여 동작(*메모리*)

두 기준은 서로 상충하는 경우가 많으며, *8장 동적 계획법*의 경우 많은 메모리를 사용하여 수행 속도를 높이는 대표적인 예이다.

이번 2부에는 알고리즘의 속도를 분석하는 방법과 알고리즘의 정당성을 증명하는 기술을 소개한다.ㄴ

## Chapter4. 알고리즘의 시간 복잡도 분석

알고리즘의 속도는 프로그램 수행 시간을 측정하는 것이 현실적으로 유용하다.
하지만, 프로그램의 수행 시간은 사용한 프로그래밍 언어, 하드웨어, 운영체제 등 다양한 요소에 의해서 바뀔 수 있기때문에 알고리즘 속도의 기준으로 사용하기에는 부적합하다. 또, 프로그램의 실제 수행 시간이 다양한 입력에 대한 실행 시간을 반영하지 못하기 때문이다. 

그러면 알고리즘의 수행 시간을 어떤 기준으로 측정해야할까?

```
    반복문의 지배!!!
```

알고리즘의 수행시간을 지배하는 것은 반복문이다.
프로그램은 대게 입력의 크기에 따라 수행 횟수가 정해지는 반복문이 있기 마련이고, 반복하는 동작이 많을 수록 수행시간이 길어진다. (*물론 예외도 존재한다*)
그래서 반복문이 수행되는 횟수로 알고리즘의 수행시간을 측정하고, 반복문의 수행횟수는 입력의 크기에 대한 함수로 표현합니다.

* **코드4.1 주어진배열에서 가장 많이 등장하는 숫자를 반환하기**
```C++
int majority1(const vecotr<int>& A)
{
    int N = A.size();
    int majority = -1, majorityCount = 0;
    for (int i = 0; i<N; ++i)
    {
        int V = A[i], count = 0;
        for(int j = 0; j<N; ++j)
        {
            if(A[j]==V) ++count;
        }
        if(count > majorityCount)
        {
            majorityCOunt = count;
            majority = V;
        }
    }
    return majority;
}
```

코드 4.1에서 알고리즘의 수행 시간은 배열의 크기 N에 따라서 변하게 된다. N번 수행하는 반복문이 두 개 겹쳐져 있으므로, 반복문의 안쪽은 $N^2$번 실행된다. 따라서 코드4.1의 알고리즘 수행 시간은 $N^2$이다.